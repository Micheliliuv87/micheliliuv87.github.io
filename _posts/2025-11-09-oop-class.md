---
layout: distill
title: OOP Class Tutorial 1
date: 2025-11-09 13:47:33
description: "Class basics, from understanding to use"
tags: Notes
categories: "CS"
citation: true
authors:
  - name: Micheli Liu
    url: "https://micheliliuv87.github.io/"
    affiliations: 
        name: Emory University ISOM

toc:
  - name: Sparse Autoencoder (SAE)
giscus_comments: true

---

# **Object Oriented Programming (OOP)**

## **What is it? **

Imagine you want to build a LEGO city using code, you will not start with hand-building each house/car/citizen. What you will do instead is to first have a design, which we call blue print (a **Class**). Then you will build based on multiple blue prints to manufacture production (create **Object**). These products should all have their own characteristics (**Attributes**) and abilities (**Methods**). Thatâ€™s the core idea of OOP: organizing code around things (objects) rather than just a sequence of commands.

## **Four Central Pillars**

### 1. **Class** and **Object**

* **Class** = Blue print for design 
* **Object** = Product desigend based on blue print

```python
# Class: Car design 
class car: 
  def __init__(self, color, brand):
    self.color = color # attribute: color
    self.brand = brand # attribute: brand 

  def run(self):  # method: drive
    print(f"{self.color}color{self.brand}is driving!")

# build the object 
my_car = car("red", "BMW") # based on blue print build a red BMW
your_car = car("blue", "Mercedes-Benz") # then build a Mercedes-Benz

my_car.run() # output red BWM is driving!
your_car.run() # output blue Mercedes-Benz is driving! 
```
```md
red BWM is driving!
blue Mercedes-Benz is driving! 
```

### **2. Encapsulation** 

Imagine your cellphone as a black-box: 
* What you need to know is how to use buttons (**Method**)
* What you don't need to kniw is how it is wired and its circuit (Hiding details)

similar for a bank account, you do not need to understand why each clickble button works on your banking mobile app. 

```python 
class BankAccount: 
  def __init__(self):
    self.__balance = 0 # private attribute (two under scores)

  def deposit(self, money): # public method 
    if money > 0:
      self.__balance += money

  def check_balance(self):
    return self.__balance

# use case 
account = BankAccount()
account.deposit(1000)
print(account.check_balance()) # output 1000
# account.__balance # this will give you error, because it cannot directly visit private attribute 
```
```md
1000
```

### **3. Inheritance**

Imagine multiple classes, you allow one class to inherit characteristics(**Attribute**) and behaviors(**Method**) from another class. So your newly built class is based on the previous ones (like you inherit your DNA from your parents). 

What the example is how you can make an animal (cat) breathe and meow. 

```python
class Animal:
  def breathe(self):
    print("Breathing...")

class Cat(Animal): # inherit Animal Class
  def meow(self):
    print("Meowing!")

my_cat = Cat()
my_cat.breathe() # inherit method -> output: Breathing... 
my_cat.meow() # own method -> output: Meowing!
```
```md
Breathing...
Meowing!
```

If you get this, let's go deeper:

Think of cat's hierarchical relationship of biological classification:

* Animal $\rightarrow$ Mammals $\rightarrow$ Felidae $\rightarrow$ Domestic Cats 
  
(you can think of other examples in your own practice)

```python
class Animal: 
    def __init__(self, name):
        self.name = name 

class Mammal(Animal):
    def speak(self):
        return f"{self.name} is a mammal."
    
class Felidae(Mammal):
    def speak(self):
        return f"{self.name} is a mammal and a member of the Felidae family."
    
class Cat(Felidae):
    def speak(self):
        return f"{self.name} Meowed! Saying I am a mammal, and a member of the Felidae family."
    
# use case 
my_cat = Cat("Whiskers")
print(my_cat.speak())               # Output: Whiskers Meowed! Saying I am a mammal, and a member of the Felidae family.

# if I want to specifically call the Mammal's speak method
print(Mammal.speak(my_cat))        # Output: Whiskers is a mammal.

# same for Felidae
print(Felidae.speak(my_cat))       # Output: Whiskers is a mammal and a member of the Felidae family
```
```md
Whiskers Meowed! Saying I am a mammal, and a member of the Felidae family.
Whiskers is a mammal.
Whiskers is a mammal and a member of the Felidae family.
```


### **4. Polymorphism**

The idea is to define multiple **methods** with the same name in different **classes**. Then you can call each based on the **object** you are calling. 

When you are using APPs on your smart phone, the same `play` botton will do: 
* Music APP: play songs 
* Video APP: play film

```python
class MediaPlayer: 
  def play(self):
    pass # meaning you don't run this but make it as a placeholder

class AudioPlayer(MediaPlayer):
  def play(self):
    print("Play MP3 Music")

class VideoPlayer(MediaPlayer):
  def play(self):
    print("Play MP4 Video")

# use the same API call 
players = [VideoPlayer(),AudioPlayer()] # you first build two different players 
for player in players:
  player.play()
```
```md
Play MP4 Video
Play MP3 Music
```

If you understood the previous lets go deeper: 

Think of animal example we had, but this time we add dog and make them speak differently. 

```python
class Animal: 
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Woof!"
    
class Cat(Animal):
    def sound(self):
        return "Meow!"

# use case
animals = [Dog(),Cat()]
for animal in animals: 
    print(animal.sound())

print("-----")
# if you only want to make dog sound
dog = Dog()
print(dog.sound())  # Output: Woof!
```
```md
Woof!
Meow!
-----
Woof!
```

## **So Why OOP?**

Comparing to traditional programming, if you were to design a school management system

**Procedural Programming:**

```python
# naming attributes on them own (mostly configs)
student1_name = "Bob"
student1_age = "19"
student1_grade = 85

teacher1_name = "Dr.Liu"
teacher1_subject = "ISOM"

# function for parsing through attributes 
def print_student_info(name, age, grade):
  print(f"Student {name}, age {age}, grade {grade}")

def print_teacher_info(name,subject):
  print(f"Teacher {name}, teaching {subject}")

# using the functions
print_student_info(student1_name,student1_age,student1_grade)
print_teacher_info(teacher1_name,teacher1_subject)

# if you want to print what Dr.Liu is teaching
print(teacher1_subject)

print("-----")

# if you want to add another student let's say student2 is Mick
student2_name = "Mick"
student2_age = 25
student2_grade = 100
print_student_info(student2_name,student2_age,student2_grade)
```
```md
Student Bob, age 19, grade 85
Teacher Dr.Liu, teaching ISOM
ISOM
-----
Student Mick, age 25, grade 100
```

**OOP Programming:**

```python
class Student: 
  def __init__(self, name, age, grade):
    self.name = name
    self.age = age
    self.grade = grade

  def print_info(self):
    print(f"Student {self.name}, age {self.age}, grade {self.grade}")

class Teacher: 
  def __init__(self, name, subject):
    self.name = name
    self.subject = subject 

  def print_info(self):
    print(f"Teacher {self.name}, teaching {self.subject}")

# use case
student1 = Student("Bob", 19, 85)
teacher1 = Teacher("Dr.Liu", "ISOM")

student1.print_info()
teacher1.print_info()

# if you want to print specific like teacher's subject 
print(teacher1.subject)

print("-----")
# if you want to add another student let's say student2 is Mick
student2 = Student("Mick", 25, 100)

student2.print_info()
```
```md
student Bob, age 19, grade 85
teacher Dr.Liu, teaching ISOM
ISOM
-----
student Mick, age 25, grade 100
```

To compare the differences see the table: 

| Aspect              | Procedural Programming                | Object-Oriented Programming (OOP)    |
|---------------------|---------------------------------------|--------------------------------------|
| Code Organization   | Data and functions are separate        | Data and methods are bound within objects |
| Maintenance Cost    | Modifications may affect many places   | Changes are concentrated within the class |
| Extensibility       | Adding new features often requires refactoring | Easily extended via inheritance         |
| Code Reuse          | Copying and pasting code segments      | Reuse via class inheritance               |
| Real-World Mapping  | Less intuitive for human thinking      | Intuitive, like building blocks (Lego)    |


## **When to use OOP?**

* When the system contains multiple similar entities (e.g., Web merchants' products/orders/users)
* Your project requires long-term maintenance
* Need to build complex interactive relationships (one class works with another)
* Developed collaboratively by multiple developers (with decoupling of modules)

A more comprehensive example: 

```python 
class Book: 
  def __init__(self, title, author, pages):
    self.title = title
    self.author = author
    self.pages = pages

  def get_info(self):
    print(f"You purchased a book: Book title: {self.title}, Author: {self.author}, Pages: {self.pages}")

  def read_page(self, n): 
    if n <= self.pages:
      print(f"Now reading \"{self.title}\" by {self.author}, page: {n}")
    else: 
      print("Finished Reading!")

# creating objects 
book1 = Book("How to Learn Python", "Dr.CS", 200)
book2 = Book("You Should Know Statistics", "Dr.SAT", 500)

# reading book 1
book1.get_info()
print("reading 100 pages...")
book1.read_page(100)

print("-----")

# reading book 2 
book2.get_info()
print("reading 600 pages...")
book2.read_page(600)
```
```md 
You purchased a book: Book title: How to Learn Python, Author: Dr.CS, Pages: 200
reading 100 pages...
Now reading "How to Learn Python" by Dr.CS, page: 100
-----
You purchased a book: Book title: You Should Know Statistics, Author: Dr.SAT, Pages: 500
reading 600 pages...
Finished Reading!
```